<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LLM Plays Pokémon - VueJS UI</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="style.css">

    <style>
        /* --- Existing Styles --- */
        .log {
            position: relative;
        }
        .log-item-move,
        .log-item-enter-active,
        .log-item-leave-active {
            transition: all 0.5s ease;
        }
        .log-item-enter-from {
            opacity: 0;
            transform: translateY(15px);
        }
        .log-item-leave-to {
            opacity: 0;
            transform: translateX(-30px);
        }
        .log-item-leave-active {
            position: absolute;
            width: 100%;
        }

        /* --- Style for ws-status positioning --- */
        .ws-status {
            /* Existing styles */
            margin-left: 15px;
            font-size: 0.9em;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            vertical-align: middle; /* Keep this for vertical alignment relative to the text */

            /* --- MODIFIED: ADDED float --- */
            float: right; /* Float the element to the right */
            /* --- END MODIFICATION --- */
        }

        /* --- Added clearfix for the status container (good practice with floats) --- */
        .status::after {
            content: "";
            display: table;
            clear: both;
        }
        /* --- END ADDITION --- */


        .ws-status.disconnected { background-color: #bdbdbd; }
        .ws-status.connecting { background-color: #ffb74d; }
        .ws-status.connected { background-color: #81c784; }
        .ws-status.error { background-color: #e57373; }
        .ws-status.reconnecting { background-color: #64b5f6; }

        .pokemon.empty-slot {
            background: #e0e0e0;
            border: 2px dashed #bdbdbd;
            color: #9e9e9e;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            min-height: 80px;
        }
        .pokemon {
            background-image: linear-gradient(to bottom, rgba(255,255,255,0.15), #aaaaaa);
            transition: opacity 0.4s ease, filter 0.4s ease;
        }
        .pokemon.fainted {
            opacity: 0.5;
            filter: grayscale(80%);
        }

        /* --- Style for Coordinates --- */
        .coordinate {
            background-color: #e0f7fa; /* Light cyan background */
            color: #006064;          /* Dark cyan text */
            padding: 1px 3px;
            border-radius: 3px;
            font-weight: bold;
            font-family: monospace; /* Good for displaying coordinates */
            margin: 0 1px; /* Small spacing adjustment */
        }
        .log-entry {
             white-space: pre-wrap; /* Preserve whitespace/newlines */
             word-wrap: break-word; /* Break long words/lines */
        }
         /* Style for other log sections if needed */
        .goals-log .log-entry {
            margin-bottom: 0.5em; /* Example spacing */
        }
        .goals-log ul {
            padding-left: 20px;
            margin-top: 0.2em;
        }
        .goals-log h3 {
             margin-bottom: 0.3em;
        }

        /* --- Added Style for Actions --- */
        .action-type-ab {
            color: #c62828; /* Red */
            font-weight: bold;
            background-color: #ffebee; /* Light Red background */
            padding: 0px 2px; /* Adjusted padding slightly */
            border-radius: 3px;
            font-family: monospace;
            margin: 0 1px; /* Small spacing */
            display: inline-block; /* Ensures spacing works */
        }

        .action-type-direction {
            color: #1565c0; /* Blue */
            font-weight: bold;
            background-color: #e3f2fd; /* Light Blue background */
            padding: 0px 2px; /* Adjusted padding slightly */
            border-radius: 3px;
            font-family: monospace;
            margin: 0 1px; /* Small spacing */
            display: inline-block; /* Ensures spacing works */
        }

    </style>
</head>

<body>
    <div id="app">
        <!-- Header Section -->
        <div class="header">
             <div class="stats-widget">
                <div class="actions-container">
                    <div class="widget-title">ACTIONS</div>
                    <div class="actions-count">{{ actions.toLocaleString() }}</div>
                    <div class="subinfo">
                        <span>Model: {{ modelName }}</span>
                        <span>Tokens: {{ tokensUsed.toLocaleString() }}</span>
                        <span>GG: T-{{ ggValue !== null ? ggValue : 'N/A' }} | Summary: T-{{ summaryValue !== null ? summaryValue : 'N/A' }}</span>
                    </div>
                </div>
                <div class="badges-widget">
                    <div class="widget-title">BADGES - {{ badges.length }}/8</div>
                    <div class="badges">
                        <div class="badge" v-for="(badge, i) in badges" :key="'badge-' + i"></div>
                        <div class="badge empty" v-for="(empty, i) in Math.max(0, 8 - badges.length)" :key="'empty-badge-' + i"></div>
                    </div>
                </div>
            </div>
            <div class="title">LLM PLAYS POKÉMON</div>
        </div>

        <!-- Left Column (Log) -->
        <div class="left-col">
            <!-- Status Bar -->
            <div class="status">
                <span>Game Status: {{ gameStatus }}</span>
                <!-- WebSocket Status (Now Floated Right) -->
                <span v-if="websocketStatus" :class="['ws-status', websocketStatus.toLowerCase().replace('...','')]">
                    • {{ websocketStatus }}
                </span>
            </div>
            <!-- Action Log -->
            <div class="log" ref="actionLogContainer">
                <transition-group name="log-item" tag="div">
                    <div class="log-entry" v-for="(entry) in displayedLogs" :key="entry.id">
                        <strong>#{{ entry.id }}:</strong>
                        <span v-html="formatLogText(entry.text)"></span>
                    </div>
                </transition-group>
            </div>
        </div>

        <!-- Middle Column (Goals) -->
        <div class="goals-log">
            <div class="log" ref="goalsLogContainer">
                 <h3>Primary Goal</h3>
                 <p class="log-entry" v-html="formatLogText(goals.primary)"></p>
                 <h3>Secondary Goals</h3>
                 <ul>
                     <li class="log-entry" v-for="(g,i) in goals.secondary" :key="'sec-'+i" v-html="formatLogText(g)"></li>
                 </ul>
                 <h3>Tertiary Goal</h3>
                 <p class="log-entry" v-html="formatLogText(goals.tertiary)"></p>
                 <h3>Other Notes</h3>
                 <p class="log-entry" v-html="formatLogText(otherGoals)"></p>
            </div>
        </div>

        <!-- Right Column (Game Feed & Team) -->
        <div class="feed-wrapper">
             <div class="game-feed">
                <div class="game-placeholder">Game Feed Placeholder</div>
                <div class="minimap-container">
                    <div class="minimap-header">{{ minimapLocation }}</div>
                    <div class="minimap-body"></div>
                </div>
            </div>
            <div class="team-bar">
                <div class="pokemon"
                     v-for="(p,i) in currentTeam"
                     :key="'team-'+i"
                     :class="{ fainted: p.hp <= 0 }"
                     :style="{ backgroundImage: `linear-gradient(to bottom, rgba(255,255,255,0.15), ${typeColors[p.type] || '#aaaaaa'})` }">
                    <div>
                        <div class="pokemon-name">{{ p.name }}</div>
                        <div class="pokemon-level">Lv {{ p.level }}</div>
                        <div class="pokemon-type">{{ p.type }}</div>
                    </div>
                    <div>
                        <div class="hp-bar">
                            <div class="hp-fill" :style="{ width: p.maxHp > 0 ? (p.hp / p.maxHp * 100) + '%' : '0%' }"></div>
                        </div>
                        <div class="hp-text">{{ p.hp }} / {{ p.maxHp }}</div>
                    </div>
                </div>
                 <div class="pokemon empty-slot" v-for="i in Math.max(0, 6 - currentTeam.length)" :key="'empty-slot-'+i">
                     EMPTY
                 </div>
            </div>
        </div>

    </div>

    <script>
        // --- Keep the existing Vue script block exactly the same ---
        const MAX_LOG_ENTRIES = 30;
        const WEBSOCKET_URL = 'ws://localhost:8765';
        const RECONNECT_INTERVAL = 5000;

        Vue.createApp({
            data() {
                 return {
                    actions: 0, badges: [], gameStatus: 'Connecting...', logs: [],
                    goals: { primary: 'Loading...', secondary: [], tertiary: 'Loading...' },
                    otherGoals: 'Loading...', currentTeam: [], modelName: 'N/A', tokensUsed: 0,
                    ggValue: null, summaryValue: null, minimapLocation: 'Unknown Area',
                    typeColors: { Water: '#4fc3f7', Grass: '#81c784', Poison: '#ba68c8', Electric: '#ffd54f', Rock: '#a1887f', Ground: '#d7ccc8', Fighting: '#e57373', Normal: '#bdbdbd', Bug: '#cddc39', Ghost: '#9575cd', Steel: '#b0bec5', Fire: '#ff8a65', Psychic: '#f06292', Ice: '#80deea', Dragon: '#7e57c2', Dark: '#757575', Fairy: '#f48fb1', Flying: '#90a4ae' },
                    websocket: null, websocketUrl: WEBSOCKET_URL, websocketStatus: 'Disconnected',
                    reconnectInterval: RECONNECT_INTERVAL, reconnectTimer: null
                };
            },
            computed: {
                displayedLogs() {
                    return this.logs;
                }
            },
            methods: {
                connectWebSocket() {
                    console.log(`Attempting to connect to ${this.websocketUrl}...`); this.websocketStatus = 'Connecting';
                    if (this.reconnectTimer) { clearTimeout(this.reconnectTimer); this.reconnectTimer = null; }
                    if (this.websocket && this.websocket.readyState !== WebSocket.CLOSED) { console.log("Closing existing WebSocket connection before reconnecting."); this.websocket.onclose = null; this.websocket.close(); }
                    try { this.websocket = new WebSocket(this.websocketUrl); } catch (error) { console.error("Failed to create WebSocket:", error); this.websocketStatus = 'Error'; this.scheduleReconnect(); return; }
                    this.websocket.onopen = (event) => { console.log('WebSocket connection established.'); this.websocketStatus = 'Connected'; };
                    this.websocket.onmessage = (event) => { try { const message = JSON.parse(event.data); this.processWebSocketMessage(message); } catch (e) { console.error('Failed to parse message or update data:', e, event.data); } };
                    this.websocket.onerror = (event) => { console.error('WebSocket error observed.'); this.websocketStatus = 'Error'; };
                    this.websocket.onclose = (event) => {
                        console.log(`WebSocket connection closed: Code=${event.code}, Reason='${event.reason}'`); this.websocket = null;
                        if (event.code !== 1000 && !this.reconnectTimer) { console.log("Connection closed unexpectedly or failed to connect. Attempting to reconnect..."); this.websocketStatus = 'Disconnected'; this.scheduleReconnect(); }
                        else if (event.code === 1000) { this.websocketStatus = 'Disconnected'; } else { if(this.websocketStatus !== 'Reconnecting...') { this.websocketStatus = 'Disconnected'; } }
                    };
                },
                 processWebSocketMessage(message) {
                    for (const key in message) {
                        if (!message.hasOwnProperty(key)) { continue; }
                        if (key === 'log_entry') {
                            if (typeof message.log_entry === 'object' && message.log_entry !== null && message.log_entry.id != null) {
                                if (!Array.isArray(this.logs)) { this.logs = []; }
                                this.logs.push(message.log_entry);
                                if (this.logs.length > MAX_LOG_ENTRIES) {
                                    this.logs.splice(0, this.logs.length - MAX_LOG_ENTRIES);
                                }
                                this.scrollToBottom(this.$refs.actionLogContainer);
                            } else { console.warn(`Received invalid 'log_entry':`, message.log_entry); }
                        } else if (key === 'logs') {
                             if (Array.isArray(message.logs)) {
                                console.log("Received full 'logs' array, replacing local logs.");
                                this.logs = message.logs.slice(-MAX_LOG_ENTRIES);
                                this.scrollToBottom(this.$refs.actionLogContainer);
                            } else { console.warn(`Received 'logs' key but the value was not an array:`, message.logs); }
                        } else if (this.$data.hasOwnProperty(key)) {
                            if (this[key] === null || typeof this[key] === typeof message[key] || (Array.isArray(this[key]) && Array.isArray(message[key])) || (typeof this[key] === 'object' && typeof message[key] === 'object' && !Array.isArray(this[key]) && !Array.isArray(message[key])) ) {
                                this[key] = message[key];
                            } else {
                                console.warn(`Type mismatch for key '${key}'. Local type: ${typeof this[key]} (${Array.isArray(this[key]) ? 'Array' : 'Object'}), Received type: ${typeof message[key]} (${Array.isArray(message[key]) ? 'Array' : 'Object'}). Update skipped.`);
                            }
                        }
                    }
                },
                scheduleReconnect() {
                    if (this.reconnectTimer) { return; } this.websocketStatus = 'Reconnecting...';
                    console.log(`Scheduling reconnect in ${this.reconnectInterval / 1000} seconds...`);
                    this.reconnectTimer = setTimeout(() => { this.reconnectTimer = null; this.connectWebSocket(); }, this.reconnectInterval);
                },
                scrollToBottom(container) {
                     if (container) { this.$nextTick(() => { container.scrollTop = container.scrollHeight; }); }
                },
                formatLogText(text) {
                    if (typeof text !== 'string' || !text) { return text; }
                    let formattedText = text;
                    const coordRegex = /(\[\d+,\s*\d+\])/g;
                    formattedText = formattedText.replace(coordRegex, (match) => {
                        return `<span class="coordinate">${match}</span>`;
                    });
                    const actionSequenceRegex = /(Action:\s*)([ABUDLRS][\s;ABUDLRS]*?)(?=[^ABUDLRS\s;]|$)/g;
                    formattedText = formattedText.replace(actionSequenceRegex, (fullMatch, prefix, sequence) => {
                        let cleanedSequence = sequence.replace(/;/g, '').replace(/\s+/g, ' ').trim();
                        let highlightedSequence = '';
                        for (const actionChar of cleanedSequence) {
                             if (actionChar === ' ') { highlightedSequence += ' '; }
                             else if (/[AB]/.test(actionChar)) { highlightedSequence += `<span class="action-type-ab">${actionChar}</span>`; }
                             else if (/[UDLRS]/.test(actionChar)) { highlightedSequence += `<span class="action-type-direction">${actionChar}</span>`; }
                        }
                        return prefix + highlightedSequence;
                    });
                    return formattedText;
                }
            },
            mounted() {
                console.log("Vue app mounted. Connecting WebSocket...");
                this.connectWebSocket();
            },
            beforeUnmount() {
                console.log("Vue app unmounting. Cleaning up WebSocket and timers.");
                if (this.reconnectTimer) { clearTimeout(this.reconnectTimer); this.reconnectTimer = null; }
                if (this.websocket) { console.log('Closing WebSocket connection.'); this.websocket.onclose = null; this.websocket.close(1000, "Client component unmounting"); this.websocket = null; }
            }
        }).mount('#app');
    </script>

</body>
</html>